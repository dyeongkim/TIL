# 1장 

# 2장 

## 정수표현 

**부호없는정수**

**부호화정수** 
- 0이 2개
- 연산이 느림 

**2의보수** 
- 0이 1개
- 가산기만으로 계산가능(연산이 빠름) 

## 실수표현 

### 고정소수점표현 

### 부동소수점표현 

- 부호 지수 가수 형태로 저장됨 

- 지수 N비트 초과표현 

- 부동소수점 표현 방식으로 변환하는 방법 

    1. 2진수로 변환한다. 
    2. 정규화한다 
    3. 부호, 지수(N비트 초과표현), 가수 순서대로 적는다 

*정규화란*
- 소수점을 옮겨서 정수가 1인형태로 만들기 

## 논리회로

![논리회로](https://user-images.githubusercontent.com/113990279/233937970-20064e41-9026-49d3-b288-209ecb94f151.png)

### 가산기
### 전가산기
### 리플캐리 전가산기

# 어셈블리어
문자찍는거, 숫자입력받아서 더하기, 어드레싱모드   
2의보수표현섞어서 문제

# 3장 컴퓨터 구조
## CPU/중앙처리장치
> 프로그램의 명령어와 데이터를 읽어 와서 명령어를 실행하고 입력된 데이터를 처리함

- CPU 구성
    - 산술논리연산장치(ALU)
    - 제어장치(CU)
    - 레지스터

## 기억장치
![저장장치](https://user-images.githubusercontent.com/113990279/233938131-fca998a1-7183-4289-a924-332b20a3f2d8.png)

- 레지스터
    - 
- 캐시메모리
    - 연관 사상
    - 지역성
        - 시간적 지역성
        - 공간적 지역성
    - 히트레이트
- RAM/주기억장치
    - 랜덤 액세스
- 하드디스크
    - 직접 접근
- 테이프
    - 순차 접근
### DMA(Direct Memory Access)
> CPU의 개입 없이 주변장치들이 메모리에 직접 접근하여 읽거나 쓸 수 있도록 하는 기능

## 시스템 버스
- 데이터 버스
    - CPU와 다른 장치 사이 or CPU 내부 모듈 사이에서 데이터가 이동하는 경로
- 주소 버스
    - CPU가 사용하고자 하는 데이터의 주소가 이동하는 경로
    - 주소 버스의 비트 수, 즉 버스의 대역폭이 주기억장치의 용량을 결정
- 제어버스
    - CPU가 기억장치, 입출력장치에 제어 신호를 전달하는 통로
    - 제어 명령, 상태 신호

## 폰노이만 구조
내장형 프로그램
- 하드웨어는 그대로 둔 채 주기억장치에서 프로그램만 교체해 실행하는 방식

**하드와이어드 프로그래밍**   
하드웨어의 외부 스위치를 껐다 켜거나 선의 연결 구조를 변경하는 것

### 명령어 수행 사이클(Instruction Execution Cycle)
1. 명령어 인출
    - 명령어를 프로그램 카운터(PC)레지스터에서 꺼내서 CPU내부의 명령어 레지스터에 저장(IR)
2. 명령어 해독
    - 인출된 명령어의 종류를 해독
3. 명령어 실행
    - 명령어 해독 결과에 적합한 제어신호를 찾아 제어 버스로 전송(실행)

### 파이프라이닝
> 한 번에 하나의 명령어만 실행하는 것이 아니라 하나의 명령어가 실행되는 도중에 다른 명령어의 실행을 시작함으로써 동시에 명령어 여러 개를 실행하는 방식

- CISC
    - 복잡한 명령어 집합을 수백 개 이상 탑재하고 있는 프로세서
    - 명령어의 길이가 가변적(파이프라인 처리가 불가능하거나 쉽지않음.)
- RISC
    - CPU의 명령어를 최소화하여 단순하게 제작된 프로세서
    - 명령어의 길이가 고정되어 파이프라인 처리의 고속화 가능
    - 컴파일러의 최적화 과정이 복잡

### 인터럽트
> CPU가 특정한 기능을 수행하던 중 급하게 다른 일을 처리하고자 할 때 사용하는 기능
- 입출력 인터럽트(I/O Interrupt)
- 소프트웨어 인터럽트

*DMA 참고


## 병렬컴퓨터
> 동시에 동작하는 CPU 여러 대 갖추고 있는 컴퓨터에서만 실행할 수 있는 처리 방식
- SIMD
    - 모든 CPU가 같은 명령어를 수행하지만 병렬적으로는 다른 데이터를 처리
- MIMD
    - 각각의 CPU가 다른 프로그램을 수행하면서 다른 데이터 처리
- SISD
    - 하나의 프로그램을 수행할 때 하나의 데이터 처리

### 대규모 병렬컴퓨팅 환경
- 클러스터
    - 근거리 네트워크(LAN)를 통해 연결된 컴퓨터들이 하나의 대형 멀티프로세서로 동작하는 시스템
- 그리드
    - 광역 네트워크 기반의 동적인 구조
    - 네트워크에 연결된 여러 대의 컴퓨터가 연산

# 4장 운영체제
> 하드웨어 장치를 관리, 사용자가 컴퓨터를 편하게 사용할 수 있는 환경 제공, 응용 소프트웨어의 효율적인 실행 지원하는 시스템 소프트웨어

## 프로세스

![프로세스_상태전이도](https://user-images.githubusercontent.com/113990279/229357084-ddc1160f-8e50-4b94-82a2-07ee5f076a1d.png)

**프로세스 상태도**
- *생성/New*
    - 프로세스가 생성되어 시스템에 등록되는 상태
    - 메모리에 할당되지 않음

- *준비/Ready*
    - 프로세스가 메모리에 할당되어 CPU를 기다리는 상태
    - 스케줄러에 의해 CPU를 할당받기를 기다림

- *실행/Running*
    - CPU를 할당받아 명령어를 실행하는 상태
        - 종료 : 프로세스의 모든 작업이 끝나면 종료
        - 중단/방해 : CPU할당 시간이 완료되거나 방해가 발생하면 준비 상태로 넘어감
        - 입출력 또는 이벤트 기다림 : 실행 중인 프로세스가 입출력 명령을 마치면 CPU사용을 반납하고 입출력 종료 신호가 올 때까지 대기 상태로 넘어감

- *대기/Waiting*
    - 입출력 작업이나 다른 프로세스의 결과를 기다리는 상태
    - CPU를 할당받지 않으며, 필요한 작업이 완료되면 다시 *Ready*상태로 돌아감

- *종료/Terminated*
    - 실행을 완료하거나 중단된 상태
    - 시스템에서 제거되고 사용하던 자원을 회수

### 프로세스 제어 블록(PCB)
> 프로세스 관리에 필요한 거의 모든 정보가 저장 되어 있는 장소(운영체제가 관리)

### 문맥 전환(Context switching)
> 프로세스가 사용하는 제리스터 값 등을 해당 프로세스의 PCB에 저장하고, 새로운 프로세스의 레지스터 값 등은 CPU에 적재하는 과정

### 프로세스 스케줄링

- 선도착 선처리 기법(FCFS : First Come First Served)
    - 먼저 생성된, 먼저 준비 상태로 들어온 프로세스 먼저 실행
- 최단작업 우선 기법(SJF : Shortest Job First)
    - 준비 상태에 있는 프로세스 중 CPU 사용 시간이 가장 짧은 것부터 실행
- 순환 순서 기법(RR : Round Robin)
    - 여러 프로세스가 돌아가면서 CPU를 조금씩 차지

### 병행프로세스
> 2개 이상의 프로세스가 동시에 실행되는 것

#### 오류를 막기 위해 사용하는 개념
- 동기화(Synchronization)
    - 하나의 자원에 2개 이상의 프로세스가 동시에 접근했을 때 처리 순서를 정해 일관성 유지
- 임계 영역(Critical Section)
    - 병행 프로세스의 코드 영역 중 자원을 읽고 수정하는 등의 작업이 이루어지는 부분.
- 상호 배제(Mutual Exclusion)
    - 하나의 프로세스가 공유 자원을 사용하는 동안 다른 프로세스가 자원을 사용하지 못하게 막는 것.

### 교착상태(Deadlock)
> 2개 이상의 프로세스가 절대 일어나지 않을 이벤트를 기다리고 있는 상태

#### 교착 상태에 빠지는 조건
- 상호 배제(Mutual exclusion)
    - 오직 하나의 프로세스만 자원을 사용할 수 있다는 조건
- 보유와 대기(hold and wait)
    - 자원을 할당받은 상태에서 다른 자원을 기다리는 것
- 비선점(no pre-emption)
    - 한 프로세스가 작업을 끝내기 전까진 다른 프로세스가 해당 자원을 뺏을 수 없다는 것
- 순환대기(circular wait)
    - 각 프로세스가 자원을 가지고 있는 상태에서 다른 프로세스의 자원을 요청하는 것

#### 교착 상태를 해결하기 위한 운영체제의 방안
- 방지(prevention)
    - 교착 상태가 발생할 수 있는 조건 4가지 중 하나 이상을 제거해 애초에 교착 상태가 발생하지 않도록 하는 것.
- 회피(avoidance)
    - 교착 상태가 발생할 가능성이 있는지 없는지 검사하고 발생할 가능성이 없을 경우에만 자원을 할당하여 발생을 회피하는 방법
- 탐지와 회복(detection and recovery)
    - 교착 상태가 발생했을 때 이를 감지하고 상활을 해결하는 방법
- 무시(ignore)
    - 교착 상태의 발생 여부를 무시하는 것


### 메모리 관리

- **단편화** : 작업량과 분할 공간의 크기가 일치하지 않아 빈 공간이 생기는것
    - 내부 단편화
        - 작업물이 공간에 들어가 있지만 공간의 크기가 커서 빈 공간이 발생하는 것
        - 프로그램 크기 < 분할된 공간 크기
    - 외부 단편화
        - 공간의 크기가 작업물보다 작아서 빈 공간이 된 것.
        - 프로그램 크기 > 분할된 공간 크기


- 연속 할당방식
    - 고정 분할 메모리 관리
        - 메모리를 분할해 놓고 분할된 메모리 구조에 프로그램이 실행되면 적당한 위치를 할당하는 방식
        - 다른 프로세스가 침범하지 않도록 보호되어야 함.(상한 주소와 하한 주소 값이 저장된 레지스터 사용)
        - 내부 단편화 O, 외부 단편화 O
    - 가변 분할 메모리 관리
        - 고정된 분할 공간의 경계를 없애고 작업량이 맞는 공간을 할당
        - 프로세스 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
        - 내부 단편화 X, 외부 단편화 O
        - 외부 단편화 문제를 해결하기 위해 압축(compaction) 방법
            - 사용하지 않은 메모리 영역을 한쪽으로 모은다.(비용이 많이 듬)
    
#### 분할 메모리 할당 방식
- 최초 적합(First-fit)
    - 프로그램 크기보다 큰 공간 중 처음 만나는 공간을 할당
- 최적 적합(Best-fit)
    - 프로그램 크기보다 큰 공간 중 가장 작은 공간을 할당
- 최악 접합(Worst-fit)
    - 프로그램 크기보다 큰 공간 중 가장 큰 공간을 할당

#### 가상메모리
> 실행해야하는 부분만 RAM에 저장하고 나머지 프로그램은 보조기억장치에 둔 채 동작하는 방법

실행할 프로그램 크기가 메인메모리보다 크거나 개수가 많으면 제대로 실행되지 못하는 문제를 해결하기 위해 개발

- 불연속 할당방식
    - 페이징(Paging)
        - 프로그램을 일정 크기로 나누어 페이지를 만들고 페이지 단위별로 메인메모리에 올려 동작하는 방식
    - 세그먼테이션(Segmentation)
        - 가상메모리를 프로그램이나 데이터 용도에 맞춰 분할하는 기법